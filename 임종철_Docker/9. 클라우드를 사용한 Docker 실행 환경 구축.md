# 9. 클라우드를 사용한 Docker 실행 환경 구축
* Docker의 최대 매력
	- 높은 이식성
	- 온프레미스, 프라이빗 클라우드, 퍼블릭 클라우드, 하이브리드 클라우드에 이르기까지 실행 환경을 요구사항에 맞춰 자유롭게 선택 가능
* Google Cloud Platform(GCP)의 Google Kubernetes Engine(GKE)를 사용하여 Docker 실행 환경 구축

---
## 9.1 클라우드 환경에서 Docker 오케스트레이션하기

---
#### 1. 분산 환경에서의 컨테이너 운용 관리
* 스케줄링
	- 하나의 머신 : 컨테이너의 시작 및 정지
	- 멀티호스트 : 컨테이너의 시작 및 정시, 호스트 간 네트워크 연결, 스토리지 관리, 컨테이너를 어떤 호스트에서 가동시킬지 결정
	- 멀티호스트에서 필요한 다양 관리 기능 '스케줄링' 

* 대표적인 오케스트레이션 툴
	- Kubernetes
		+ Google의 오픈소스 컨테이너 오케스트레이션 툴
		+ 제공 기능 풍부, 대규모 시스템에 도입 실적 풍부, 실질적인 스탠다드
	- Docker Engine(Swarm 모드)
		+ Swarm 모드 : Docker에서 제공하는 클러스터링 기능
		+ 여러 개의 컨테이너를 멀티호스트 환경에서 작동, 그 컨테이너들을 모아서 하나의 명령으로 조작
	- Apache Mesos, Marathon
		+ 오픈소스 컨테이너 오케스트레이션 툴
		+ 대규모 클러스터 지원
		+ 여러 호스트의 CPU, 메모리, 디스크를 추상화하여 하나의 리소스 풀로 다룰 수 있는 특징
			=> Marethon 이라는 별도의 컨테이너 관리용 프레임워크가 필요
---
#### 2. 퍼블릭 클라우드가 제공하는 매니지드 서비스
* 온프레미스 환경에 도입 -> 하드웨어나 네트워크에 대한 지식이 필요
* 클라우드의 가상 머신 인스턴트 구축 -> 인프라 환경 구축, 오케스트레이션 툴, 감시 툴 사용법, 시스템 운용 밑 장애 대응 등 지식이 필요
	- 운영 난이도가 높음
* 퍼블릭 클라우드가 제공하는 '매니지드 서비스' 이용
	- 인프라에 관한 깊은 지식이 없어도 컨테이너 쉽게 운용
	- 어플리케이션 개발, Docker 이미지 작성 및 실행, 테스트 등 개발 업무 주력 가능
	
###### Amazon EC2 Container Service(Amazon ECS)
* AWS의 가상 머신 기능을 제고하는 Amazon EC2를 사용한 Docker 컨테이너 관리 서비스
	- Amazon ECS은 '태스크 정의'라고 하는 JSON 템플릿을 사용하여 환경을 정의
	- 리소스와 가용성 요구사항을 바탕으로 클러스터 전체에 컨테이너를 배치하는 스케줄러 기능
	- 컨테이너 장애 복구, 부하분산(Elastic Load Balancing - ELB) 기능
	- Amazon CloudWatch와 연계 리소스 감시 가능
	- 과학기술계산을 위한 분산 배치 처리 실행 서비스인 Amazon Batch 제공
	
###### Azure Container Service(AKS)
* Microsoft Azure의 컨테이너 매니저드 서비스, Kubernetes 지원
	- 프라이빗 registry 서비스인 Azure Container Registry 제공
	- Azure Batch Shipyrd라는 과학기술계산 등의 용도로 이옹되는 대규모 분산 배치 처리 기반의 일부로도 Docker가 이용됨

###### Google Kubernetes Engine(GKE)
* google이 제공하는 Google Cloud Platform(GCP)의 컨테이너 매니지드 서비스

---
#### 3. Google Cloud Platform의 컨테이너 관련 서비스
* Google Cloud Platform(GCP)
	- Google이 제공하는 퍼블릭 클라우드 서비스
	- 자사가 사용하는 인프라(YouTube, Gmail 등)를 일반사용자에게도 이용할 수 있도록 서비스 함

##### Google Container Builder
* Dockerfile을 바탕으로 Docker 이미지를 GCP 상에 작성하기 위한 툴
	- Dockerfile을 저장하는 '소스 리포지토리'에 저장된 'Dockerfile' -> 이미지 build하고 Container Registry로 자동 업로드
	- '소스 리포지토리'는 Google Cloud Source Repositories, GitHub, Hitbucket을 이용 가능
	- 작성한 Docker 이미지는 Google Cloude Storage(유럽/아시아/미국 리전)에 지정해 저장 가능
	- 스토리지에 액세스 사용자를 지정 가능하기에 프라이빗한 환경에서 이미지를 안전하게 관리 가능
	
##### Google Kubernetes Engine(GKE)
* Docker 컨테이너를 관리하는 풀매니지드 서비스
	- 사용자가 정의한 CPU, 메모리와 같은 인프라 요구사항을 바탕으로 컨테이너를 클러스터에 스케줄링하여 자동 관리
	- 컨테이너에 할당되는 클러스터 리소스나 컨테이너 클러스터의 크기를 조정 가능
	- Kubernetes의 kubectl 명령 또는 Cloud Console에서 조작 가능
![GKE 콘솔](./9. 클라우드를 사용한 Docker 실행 환경 구축/docker_00_GKE콘솔.png)

##### Google Container Registry
* Docker 이미지를 GCP의 제품 안에서 관리할 수 있는 프라이빗 registry 서비스
	- 저장 위치는 Google Cloude Storage(유럽/아시아/미국 리전)에서 Compute Engine 인스턴스 지리적으로 가까운 곳에 지정 가능
	- Docker Registry V2 API 사용, 프라이빗 registry에 대해 Docker 이미지 업로드(push)/다운로드(pull) 가능
	- Cloud Storage Nearline 버킷에 저장 가능
	
	
---
## 9.2 Kubernetes의 개요
* 여러 개의 호스트를 하나로 묶어 Docker를 이용하기 위한 오케스트레이션 툴
* 주요 기능	
	- 여러 서버들에서의 컨테이너 관리
	- 컨테이너 간 네트워크 관리
	- 컨테이너의 부하분산
	- 컨테이너의 감시
	- 무정지로 업데이트

---
#### 1. Kubernetes의 서버 구성
![Kubernetes 서버 구성](./9. 클라우드를 사용한 Docker 실행 환경 구축/docker_01_Kubernetes서버구성.jpg)[^출처]

##### 마스터 서버(Kubernetes Master)
* Kubernetes 클러스터 전체를 컨트럴 하는 시스템, Kubernetes 클러스터안의 컨테이너를 조작하기 위한 서버
	- 노드의 리소스 사용 상황 확인, 컨테이너 시작시 노드 자동 선택
* API 서버, 스케쥴러, 컨트롤러 매니져로 구성(etcd를 포함하기도 함)
* kubectl 명령 사용

###### API 서버
* Kubernetes의 모든 명령과 통신을 API를 통해서 처리하는 서버
* Kubernetes의 모든 기능들을 REST API로 제공하고 그에 대한 명령을 처리

###### 스케쥴러
* Pod, 서비스 등 각 리소스들을 적절한 노드에 할당하는 역할

###### 컨트롤러 매니져
* 컨트롤러(Replica controller, Service controller, Volume Controller, Node controller 등)를 생성하고 이를 각 노드에 배포하며 이를 관리하는 역할


##### 백엔드 데이터베이스(etcd)
* etcd라 부르는 분산 키 밸류 스토어(KVS)를 사용하여 클러스터 구성 정보 관리
	- 클러스터를 구축하기 위한 설정 정보
* 마스터 서버 상에 구축하기도 함, 다중화 검토 필요

##### 노드
* 실제로 Docker 컨테이너를 작동시키는 서버
* 마스터 서버로부터 명령을 받고, 실제 워크로드를 생성하여 서비스 하는 컴포넌트이기도 함
* 클라우드에서느 가상머신 인스턴스가 노드가 됨

---
#### 2. 애플리케이션 구성 관리(Pod, ReplicaSet, Deployment)

##### Pod(포드)
* 여러 개의 컨테이너를 모아서 'Pod'로 관리
* Pod 단위로 어플리케이션 관리(웹 서버 컨테이너 + 프록시 서버 컨테이너)
* Pod 안의 여러 컨테이너 가상 NIC(프라이빗 IP)를 공유함
* Pod가 여러 개의 노드에 걸칠 수는 없음(역할이 다른 기능을 하나의 Pod에 저장하면 안됨) 

##### ReplicaSet(리플리카 셋)
* 지정한 수 만큼 Pod를 항상 실행시켜 유지하는 장치
* 실행중인 Pod 감시 -> 장애와 같은 이유로 정지 -> 해당 Pod 삭제 후, 새로운 Pod 실행
* Pod의 수를 동적으로 변경하여 오토스케일 구현 가능

##### Deployment(디플로이먼트, 전개) 
* Pod와 ReplicaSet의 모음, ReplicaSet의 이력 관리
* Deployment는 ReplicaSet의 템플릿을 가지고 ReplicaSet의 작성이나 갱신함
* 이력 관리를 통해, Pod안의 컨테이너의 버전을 롤링 업데이트 및 롤백 가능
* etc : DaemonSet, Jobs, CronJob

---
#### 3. 네트워크 관리(Serviced)
* Kubernetes 클라스터 안에서 실행되는 Pod에 대해, 외부로부터 액세스할 때의 서비스를 정의
* 서비스는 Kubernetes 네트워크를 관리함
	- Load Balancer : 서비스에 대응하는 IP + Port에 액세스하면 여러 Pod에 대한 레이어 4 레벨의 부하분산이 일어남
* Cluster IP
	- 클러스터 안의 Pod끼리 통신을 하기 위한 프라이빗 IP 주소(노드 상의 Proxy 데몬이 처리)
* Externl IP
	- 외부 클라이언트가 연결하기 위한 퍼블릭 IP 주소

Ex) 서비스 정의 파일  
```
* 80번 포트
전송

* 글로벌 IP
주소

* 부하분산
```

---
#### 4.Label을 사용한 리소스 식별
* Kubernetes에서는 리소스 식별을 위한 이름이 랜덤하게 자동으로 부여됨
	- 리소스 관리하기 어려움 -> 알기 쉬운 Label을 붙임(운용 부담을 줄임)
* Key-Value형의 임의의 문자열 사용
* Label의 활용
	- 하나의 리소스에 여러 개 설정 가능(Pod의 역할별로 임의의 이름을 붙임)
	- 관련 있는 Pod별로 모아서 유연하게 관리
	- Kubernetes의 정의 파일인 매니페스트 파일 참조

Ex) 서비스 정의 파일  
```
labels:
	app: v1.0
	app: v2.0
selector:
	type: webbserver
	app: v1.0
```
* Selector 를 이용해 'app:v1.0'라는 Label이 붙은 Pod로만 리퀘스트 전송 가능

---
#### 5. Kubernetes의 구조

---
## 9.3 GCP를 사용한 Docker 어플리케이션 개발


---
#### 1. 어플리케이션 개발 흐름


Ex) GCP 프로젝트의 설정  
```zsh

```

---
#### 2. 소스코드 관리(Cloud Source Repositories) 

Ex) 샘플 앱의 다운로드  
```zsh

```

Ex) repository 작성  
```zsh

```

Ex) 리모트 설정  
```zsh

```

Ex) repository 업로드  
```zsh

```

---
#### 3. Docker 이미지 빌드(Cloud Continer Builder)


---
## 9.4 GCP를 사용한 Docker 어플리케이션 실행 환경 구축

---
#### 1. kubernetes 클러스터 구축

* 컨테이너 클러스터의 설정 값

항목|설명|이번의 설정 값
---|---|---
  

Ex) 클러스터 환경 설정  
```zsh

```

Ex) 노드 확인  
```zsh

```

---
#### 2. 어플리케이션의 설정 정보 관리(ConfigMap, Secrets)

##### 어플리케이션 프로퍼티 정보(ConfigMap)

Ex) ConfigMap 정의파일(chap09/config/configmap.yaml)  
```zsh

```

Ex) ConfigMap의 등록  
```zsh

```

##### 기밀 데이터(Secrets)

* 이번의 설정 값  
설정값 | 값 | base64 인코딩
---|---|---

Ex) Secrets 정의 파일(chap09/config/secrets.yaml)    
```zsh

```

Ex) Secrets 등록     
```zsh

```

---
#### 3. 앱의 전개(Deployment)

##### 3.1 디폴로이먼트 정의 파일의 작성
Ex) 파일의 정의(chap09/config/deployment-blue.yaml 일부)  
```zsh

```

Ex) Pod의 정의(chap09/config/deployment-blue.yaml 일부)  
```zsh

```

Ex) 환경변수의 정의(chap09/config/deployment-blue.yaml 일부)  
```zsh

```

Ex) 포트의 정의(chap09/config/deployment-blue.yaml 일부)  
```zsh

```

##### 3.2 어플리케이션의 전개

Ex) 전개  
```zsh

```

Ex) Pod 확인 1  
```zsh

```

Ex) Pod 정지 1  
```zsh

```

Ex) Pod 확인 2  
```zsh

```

Ex) Pod 정지 2  
```zsh

```

---
#### 4. 서비스 공개(Service)

##### 4.1 서비스 정의 파일 작성

Ex) 서비스 정의 파일(chap09/config/service.yaml)  
```zsh

```

##### 4.2 서비스 공개

Ex) 서비스 공개  
```zsh

```

Ex) 서비스 비공개  
```zsh

```


---
#### 5. 앱의 버전업(Blue-Green Deployment)


Ex) 불루 그린 디플로이먼트  
```zsh

```

Ex) 명령을 사용한 불루 그린 디플로이먼트  
```zsh

```

---
#### 5. 배치 잡 실행(CronJob)
` `  

Ex) CronJob 정의 파일(chap09/config/cronjob.yaml)  
```zsh

```

Ex) CronJob 실행  
```zsh

```

Ex) CronJob 확인  
```zsh

```

Ex) CronJob의 실행 내용  
```zsh

```

Ex) CronJob 삭제  
```zsh

```


---
[^출처]: http://m.comworld.co.kr/news/articleView.html?idxno=49737
